/*
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0, (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.tle.integration.oidc.service

import cats.implicits._
import com.auth0.jwt.interfaces.DecodedJWT
import com.tle.common.institution.CurrentInstitution
import com.tle.common.usermanagement.user.valuebean.DefaultUserBean
import com.tle.common.usermanagement.user.{DefaultUserState, WebAuthenticationDetails}
import com.tle.core.guice.Bind
import com.tle.core.httpclient.sttpBackend
import com.tle.core.services.user.UserService
import com.tle.integration.jwk.JwkProvider
import com.tle.integration.jwt.decodeJwt
import com.tle.integration.oauth2.error.OAuth2Error
import com.tle.integration.oauth2.error.authorisation.{
  AccessDenied,
  AuthorisationError,
  InvalidState,
  NotAuthorized,
  InvalidRequest => AuthInvalidRequest
}
import com.tle.integration.oauth2.error.general.{GeneralError, InvalidJWT, ServerError}
import com.tle.integration.oauth2.error.token.{TokenError, TokenErrorResponse}
import com.tle.integration.oauth2.generatePKCEPair
import com.tle.integration.oidc.idp.{IdentityProviderDetails, RoleConfiguration}
import com.tle.integration.oidc.{
  OpenIDConnectParams,
  getClaim,
  getClaimAsSet,
  verifyIdToken => verifyToken
}
import com.tle.integration.util.getParam
import io.circe.Error
import io.circe.generic.semiauto.{deriveDecoder, deriveEncoder}
import io.circe.parser._
import org.apache.http.client.utils.URIBuilder
import org.slf4j.LoggerFactory
import sttp.client.circe.asJson
import sttp.client.{DeserializationError, HttpError, ResponseError, UriContext, basicRequest}

import javax.inject.{Inject, Singleton}
import scala.jdk.CollectionConverters._
import scala.util.{Failure, Success, Try}

/**
  * Structure for the response of a successful ID token request as per section 3.1.3.3 of the OIDC spec
  * as well as section 5.1 of OAuth2 spec.
  */
final case class OidcTokenResponse(access_token: String,
                                   id_token: String,
                                   refresh_token: Option[String],
                                   scope: Option[String],
                                   token_type: String,
                                   expires_in: Int,
)

object OidcTokenResponse {
  implicit val tokenResponseEncoder = deriveEncoder[OidcTokenResponse]
  implicit val tokenResponseDecoder = deriveDecoder[OidcTokenResponse]
}

/**
  * Structure for a successful verification of a callback request.
  *
  * @param code Authorisation code generated by a authorisation server and can be used once only.
  * @param state The state previously generated when OEQ initiated the authentication request.
  * @param stateDetails Details of the authentication request from which the state was generated.
  */
final case class OidcCallbackDetails(code: String, state: String, stateDetails: OidcStateDetails)

/**
  * Service providing functions required in an OIDC authentication process.
  */
@Bind
@Singleton
class OidcAuthService @Inject()(
    stateService: OidcStateService,
    userService: UserService,
    oidcConfigurationService: OidcConfigurationService,
    jwkProvider: JwkProvider)(implicit val nonceService: OidcNonceService) {
  private val RESPONSE_TYPE         = "code"
  private val GRANT_TYPE            = "authorization_code"
  private val REDIRECT_URI          = s"${CurrentInstitution.get().getUrl}oidc/callback"
  private val SCOPE                 = "openid profile email"
  private val CODE_CHALLENGE_METHOD = "S256"

  private val LOGGER = LoggerFactory.getLogger(classOf[OidcAuthService])

  /**
    * Retrieve an enabled Identity Provider configuration. Missing the configuration or having a disabled
    * one will result in an error of 'server_error'.
    */
  def getIdentityProvider: Either[ServerError, IdentityProviderDetails] =
    oidcConfigurationService.get
      .filterOrElse(_.commonDetails.enabled, ServerError("Identity Provider is not enabled"))
      .leftMap(_ => ServerError("Unable to retrieve Identity Provider configuration"))

  /**
    * Based on section 3.1.2.1 of the OIDC spec and section 4.3 of the PKCE spec, build an authentication URL
    * with the following parameters to request end-user to be authenticated by their configured Identity Provider.
    *
    * - `scope` which must contain `openid`, but we also include `email` and `profile` in order to access users' email
    * and profile information (e.g. family name) for creating a valid user state after the authentication
    * - `response_type` which must be `code`
    * - `redirect_uri` which points to the OEQ endpoint `oidclogin.do`
    * - `client_id` which is the auth client ID configured in the OIDC configuration
    * - `state` and `nonce` which are not required but we include them as the best practice
    * - `code_challenge` and `code_challenge_method` required by PKCE
    *
    * @param authUrl OAuth2 authorisation endpoint of the selected Identity Provider
    * @param clientId ID of an OAuth2 client registered in the selected Identity Provider
    * @param targetPage The OEQ page which the user attempted to access before the login process
    */
  def buildAuthUrl(authUrl: String, clientId: String, targetPage: String): String = {
    val (codeVerifier, codeChallenge) = generatePKCEPair
    val stateDetails = OidcStateDetails(
      codeVerifier = codeVerifier,
      codeChallenge = codeChallenge,
      targetPage = Option(targetPage).filter(_.nonEmpty)
    )
    val state = stateService.createState(stateDetails)
    val nonce = nonceService.createNonce(state)

    val uriBuilder = new URIBuilder(authUrl)
      .addParameter(OpenIDConnectParams.CLIENT_ID, clientId)
      .addParameter(OpenIDConnectParams.RESPONSE_TYPE, RESPONSE_TYPE)
      .addParameter(OpenIDConnectParams.REDIRECT_URI, REDIRECT_URI)
      .addParameter(OpenIDConnectParams.SCOPE, SCOPE)
      .addParameter(OpenIDConnectParams.STATE, state)
      .addParameter(OpenIDConnectParams.NONCE, nonce)
      .addParameter(OpenIDConnectParams.CODE_CHALLENGE, codeChallenge)
      .addParameter(OpenIDConnectParams.CODE_CHALLENGE_METHOD, CODE_CHALLENGE_METHOD)

    uriBuilder.build().toString
  }

  /**
    * According to section 4.1.2 of the OAuth2 spec, the callback request MUST contain the parameter of 'code'.
    * And because we always add 'state' in the initial request, the callback request MUST also contain the
    * parameter of 'state', and state must be validated before requesting a token. Missing either param or
    * failing the state verification results in an error of 'invalid_request'.
    *
    * @param params The list of params from the callback request
    * @return Either an error of 'invalid_request' or the details of callback request
    */
  def verifyCallbackRequest(
      params: Map[String, Array[String]]): Either[AuthorisationError, OidcCallbackDetails] = {
    def paramMap = getParam(params)
    def paramValue(p: String) =
      paramMap(p).toRight(AuthInvalidRequest(s"Missing required parameter '$p'"))

    for {
      code  <- paramValue(OpenIDConnectParams.CODE)
      state <- paramValue(OpenIDConnectParams.STATE)
      stateDetails <- stateService
        .getState(state)
        .toRight(InvalidState(s"Invalid state provided: $state"))
    } yield OidcCallbackDetails(code, state, stateDetails)
  }

  /**
    * According to section 3.1.3.1 of the OIDC spec and section 4.5 of the PKCE spec, a Token Request
    * must contain the following parameters:
    *
    * `grant_type` which must be `authorization_code`
    * `code` which is the authorisation code received from the previous callback request
    * `redirect_uri` which points to OEQ endpoint `oidclogin.do`
    * `client_id` which is the auth client ID configured in the OIDC configuration
    * `code_verifier` which will be verified by the authorisation server with the previously sent `code_challenge`
    *
    * @param code Authorisation Code received from the previous callback request
    * @param stateDetails Details of the state where the code verifier is stored
    * @param idp Configuration of the selected Identity Provider that provides essential information for building the token request
    * @return Either an ID token issued by the Identity Provider or an error describing why the request failed
    */
  def requestIdToken(code: String,
                     stateDetails: OidcStateDetails,
                     idp: IdentityProviderDetails): Either[OAuth2Error, String] = {
    val idpDetails = idp.commonDetails
    val tokenRequest = basicRequest
      .body(
        OpenIDConnectParams.CLIENT_ID     -> idpDetails.authCodeClientId,
        OpenIDConnectParams.CLIENT_SECRET -> idpDetails.authCodeClientSecret,
        OpenIDConnectParams.CODE          -> code,
        OpenIDConnectParams.CODE_VERIFIER -> stateDetails.codeVerifier,
        OpenIDConnectParams.GRANT_TYPE    -> GRANT_TYPE,
        OpenIDConnectParams.REDIRECT_URI  -> REDIRECT_URI,
      )
      .post(uri"${idpDetails.tokenUrl}")
      .response(asJson[OidcTokenResponse])

    // Catch the potential network level errors thrown from sttp backend. Protocol level errors will be handled by 'handleTokenError'.
    Try {
      sttpBackend
        .flatMap(implicit backend => tokenRequest.send())
        .map(_.body)
        .unsafeRunSync()
        .leftMap(handleTokenError)
        .map(_.id_token)
    } match {
      case Success(result) => result
      case Failure(err) =>
        Left(ServerError(s"Failed to communicate with the Token endpoint: ${err.getMessage}"))
    }
  }

  /**
    * Given a raw ID token and a previously built `state`, decode the token and then verify it as per section 3.1.3.7
    * of the OIDC spec.
    *
    * @param token A freshly received ID token in raw string format
    * @param state Previously built state to assist in nonce verification
    * @param idp Configuration of the selected Identity Provider that provides essential information for the verification
    *
    * @return Either a verified and decoded ID token or an error describing why the verification failed
    */
  def verifyIdToken(token: String,
                    state: String,
                    idp: IdentityProviderDetails): Either[GeneralError, DecodedJWT] =
    for {
      decodedToken <- decodeJwt(token)
      idpDetails = idp.commonDetails
      jsonWebKeySetProvider <- jwkProvider.get(idpDetails.keysetUrl)
      jwk <- Either
        .catchNonFatal(jsonWebKeySetProvider.get(decodedToken.getKeyId))
        .leftMap(_ => InvalidJWT("Failed to retrieve by the obtained ID token's key ID"))
      verifiedToken <- verifyToken(decodedToken,
                                   idpDetails.issuer,
                                   idpDetails.authCodeClientId,
                                   jwk,
                                   state)
    } yield verifiedToken

  /**
    * Log the user in with a UserState built based on the supplied ID token and the OIDC configuration.
    *
    * If there is a custom username claim, attempt to retrieve a username from the ID token with this claim, or
    * use the claim `sub` as the username instead.
    *
    * If there is a role configuration, attempt to retrieve OEQ roles from the configured role mappings with the
    * ID token's custom role claim, or use the list of default roles.
    *
    * If family name and given name are absent in the ID token, default to empty strings.
    *
    * @param idToken ID token which must have been verified
    * @param wad The details of the HTTP request for this authentication attempt
    * @param idp OIDC Configuration which may have custom username claim and role configuration
    */
  def login(idToken: DecodedJWT,
            wad: WebAuthenticationDetails,
            idp: IdentityProviderDetails): Unit = {
    def claim: String => Option[String] = getClaim(idToken)

    val userId = idToken.getSubject
    val username = idp.commonDetails.usernameClaim
      .flatMap(claim)
      .getOrElse(userId)
    val user: DefaultUserBean = new DefaultUserBean(
      userId,
      username,
      claim(OpenIDConnectParams.FAMILY_NAME).getOrElse(""),
      claim(OpenIDConnectParams.GIVEN_NAME).getOrElse(""),
      claim(OpenIDConnectParams.EMAIL).orNull
    )

    val userState: DefaultUserState = new DefaultUserState
    userState.setLoggedInUser(user)
    userState.getUsersRoles.addAll(roles(idp, idToken))

    userService.setupUserState(userState, wad, true)
    userService.login(userState, true)
  }

  // If there is a role configuration, use the configured role claim and role mappings to determine the OEQ roles.
  // If the result is None or there isn't a role configuration, use the default roles instead.
  private def roles(idp: IdentityProviderDetails,
                    token: DecodedJWT): java.util.Collection[String] = {
    // Return a function that takes an IDP role and returns a set of OEQ roles based on the role mappings.
    def getOeqRolesFromMappings(mappings: Map[String, Set[String]]): String => Set[String] =
      (idpRole: String) => mappings.getOrElse(idpRole, Set.empty)

    idp.commonDetails.roleConfig
      .flatMap {
        case RoleConfiguration(roleClaim, mappings) =>
          getClaimAsSet(token, roleClaim)
            .map(_.flatMap(getOeqRolesFromMappings(mappings)))
      }
      .getOrElse(idp.commonDetails.defaultRoles)
      .asJavaCollection
  }

  /**
    * Handle the potential errors returned from the IdP token endpoint, and sttp groups the errors into two
    * categories: `DeserializationError` and `HttpError`. Depending on the received error type, return either
    * an instance of [[GeneralError]] or [[TokenError]].
    */
  private def handleTokenError(error: ResponseError[Error]): OAuth2Error = error match {
    case DeserializationError(_, error) =>
      ServerError(
        s"An ID Token has been issued but can't be retrieved from an unexpected response format: ${error.getMessage}")
    // For general HTTP client errors, the error structure should follow the OAuth2 spec as defined in `TokenErrorResponse`.
    case HttpError(body, status) if status.isClientError =>
      parse(body)
        .flatMap(_.as[TokenErrorResponse])
        .fold(
          _ => {
            LOGGER.error(s"Failed to request an ID token. Received response: $body")
            ServerError(
              "Failed to request an ID token, but the error is unknown due to unexpected response format.")
          },
          resp => {
            val msg = resp.error_description.getOrElse("No further information.")
            status.code match {
              case 400 => TokenError(resp.error, msg)
              case 401 => NotAuthorized(msg)
              case 403 => AccessDenied(msg)
              case _   => ServerError(msg)
            }
          }
        )
    case HttpError(body, status) if status.isServerError =>
      ServerError(s"Failed to request an ID token: $body")
  }
}
